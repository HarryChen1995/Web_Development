<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>Skill</title>
    <link rel="stylesheet" href="CSS/styles3.css">

  </head>

  <body>





   <div id = "skill">$My_Skill_Search_Tree   #Click <span class="dot"></span> to Expand Subtree</div>
   <div id ="skill_panel"> <h2 id = "python">Python<h2><hr><br>
                            <p>&nbsp;&nbsp; Python is considered as high level, interpreted general purposed programming language specially for data science, and machine learning,
                            computer vision because of its simplicity, community support and efficiency. It came with amazing modules and frameworks for my projects. I original came from a C programming background. But soon after I 
                            get hands on machine learning projects, I found out that python is so much fun to work with. It is so much easier to pick up compared to C/C++. 
                            Python has became my primary programming language, not just for my ML project, also my coding interviews. But I am not here to cherry pick python for all projects I worked on.
                            As programmer, I realize that it is hard to transition to other programming language from python. Specially when it came to data structures, algorithm and memory managements. I do recommend C language as good start.
                            </p>
                            <h2 id = "C++">C/C++<h2><hr><br>
                              <p>&nbsp;&nbsp; C/C++ supports object oriented features and dynamic memory allocations. It is portable and can deployed on all machines. I primarily used C/C++ for all my micro controller projects (for example-MicroChip PIC 32, TI MSP430).
                                It is actually first language that I learned in college. I learned all basic data structures
                                and algorithm in C/C++. I still remember fist coding projects for my C programming class was to implement battle ship game using two dimensional array and double link list which stored all ships for each player.
                                sunk ship had to remove from double link list. I was entrapped in confusion of pointers. But once I figured out how reference and variable address works, I quickly wrapped my head around.
                                the first idea came to my head was that creating hash table to quickly reference each ship and remove them with time complicity of O(1) instead of linear searching through entire list (O(n)). 
                                It is weird that python does not support pointer,  everything works as reference to object. Again this is why I recommend C language as good start to learn and understand all 
                                underlying concepts.
                              </p>

                        

   </div>




































<!-- load the d3.js library -->	
<script src="https://d3js.org/d3.v3.min.js"></script>
	
<script>

var treeData = [
  {
    "name": "My Skill",
    "parent": "null",
    "children": [
      {
        "name": "Programming Language",
        "parent": "My Skill",
        "link":null,
        "line":null,
        "children": [
          {
            "name": "Python",
            "parent": "Programming Language",
            "link":"#python",
            "line":"underline"
          },
          {
            "name": "C/C++",
            "parent": "Programming Language",
            "link":"#C++",
            "line":"underline"
          },
          {
            "name": "JavaScript",
            "parent": "Programming Language",
            "link":"#javascript",
            "line":"underline"
          }
        ]
      },
      {
        "name": "Web Development",
        "parent": "My Skill",
        "link":"#web_development",
        "line":"underline"

      },
      {
        "name": "Machine learning",
        "parent": "My Skill",
        "link":null,
        "line":null,
        "children": [
        {
            "name": "Neural Networks (CNN, DNN, RNN, GAN)",
            "parent": "Machine Learning",
            "link":"#neural_network",
            "line":"underline"
          },

          {
            "name": "Object Detection",
            "parent": "Machine Learning",
            "link":"#object_detection",
            "line":"underline"
          }

        ]
      },
      {
        "name": "Computer Architecture Design",
        "parent": "My Skill",
        "link":null,
        "line":null,
        "children": [
        {
            "name": "HDL (VHDL, Verilog)",
            "parent": "Computer Architecture Design",
            "link":"#hdl",
            "line":"underline"

          },

          {
            "name": "MIPS 32 assembly",
            "parent": "Computer Architecture Design",
            "link":"#mips",
            "line":"underline"
          },
          {
            "name": "Pipelining",
            "parent": "Computer Architecture Design",
            "link":"#pipeline",
            "line":"underline"
          }

        ]

      }

    ]
  }
];


// ************** Generate the tree diagram	 *****************
var margin = {top: 20, right: 120, bottom: 20, left: 120},
	width =  850 - margin.right - margin.left,
	height = 800- margin.top - margin.bottom;
	
var i = 0,
	duration = 750,
	root;

var tree = d3.layout.tree()
	.size([height, width]);

var diagonal = d3.svg.diagonal()
	.projection(function(d) { return [d.y, d.x]; });

var svg = d3.select("#skill").append("svg")
	.attr("width", width + margin.right + margin.left)
	.attr("height", height + margin.top + margin.bottom)
  .append("g")
	.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

root = treeData[0];
root.x0 = height / 2;
root.y0 = 0;



root.children.forEach(collapse);
update(root);



// Collapse the node and all it's children
function collapse(d) {
  if(d.children) {
    d._children = d.children
    d._children.forEach(collapse)
    d.children = null
  }
}


d3.select(self.frameElement).style("height", "500px");


function update(source) {

  // Compute the new tree layout.
  var nodes = tree.nodes(root).reverse(),
	  links = tree.links(nodes);

  // Normalize for fixed-depth.
  nodes.forEach(function(d) { d.y = d.depth * 180; });

  // Update the nodes…
  var node = svg.selectAll("g.node")
	  .data(nodes, function(d) { return d.id || (d.id = ++i); });

  // Enter any new nodes at the parent's previous position.
  var nodeEnter = node.enter().append("g")
	  .attr("class", "node")
	  .attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
	  .on("click", click);

  nodeEnter.append("circle")
	  .attr("r", 1e-6)
	  .style("fill", function(d) { return d._children ? "rgb(56, 231, 65)" : "rgb(34, 35, 36)"; });

  nodeEnter
     .append("a")
     .attr("xlink:href", function (d) { return d.link})
     .append("text")
	  .attr("x", function(d) { return d.children || d._children ? -13 : 13; })
	  .attr("dy", ".35em")
	  .attr("text-anchor", function(d) { return d.children || d._children ? "end" : "start"; })
    .attr("text-decoration", function(d) { return d.line })
	  .text(function(d) { return d.name; })
	  .style("fill-opacity", 1e-6);

  // Transition nodes to their new position.
  var nodeUpdate = node.transition()
	  .duration(duration)
	  .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });

  nodeUpdate.select("circle")
	  .attr("r", 10)
	  .style("fill", function(d) { return d._children ? "rgb(56, 231, 65)" : "rgb(34, 35, 36)"; });

  nodeUpdate.select("text")
	  .style("fill-opacity", 1);

  // Transition exiting nodes to the parent's new position.
  var nodeExit = node.exit().transition()
	  .duration(duration)
	  .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
	  .remove();

  nodeExit.select("circle")
	  .attr("r", 1e-6);

  nodeExit.select("text")
	  .style("fill-opacity", 1e-6);

  // Update the links…
  var link = svg.selectAll("path.link")
	  .data(links, function(d) { return d.target.id; });

  // Enter any new links at the parent's previous position.
  link.enter().insert("path", "g")
	  .attr("class", "link")
	  .attr("d", function(d) {
		var o = {x: source.x0, y: source.y0};
		return diagonal({source: o, target: o});
	  });

  // Transition links to their new position.
  link.transition()
	  .duration(duration)
	  .attr("d", diagonal);

  // Transition exiting nodes to the parent's new position.
  link.exit().transition()
	  .duration(duration)
	  .attr("d", function(d) {
		var o = {x: source.x, y: source.y};
		return diagonal({source: o, target: o});
	  })
	  .remove();

  // Stash the old positions for transition.
  nodes.forEach(function(d) {
	d.x0 = d.x;
	d.y0 = d.y;
  });
}

// Toggle children on click.
function click(d) {
  if (d.children) {
	d._children = d.children;
	d.children = null;
  } else {
	d.children = d._children;
	d._children = null;
  }
  update(d);
}

</script>
	
  </body>
</html>